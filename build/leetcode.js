/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/leetcode/LHLocalStorage.js":
/*!****************************************!*\
  !*** ./src/leetcode/LHLocalStorage.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ LHLocalStorage)\n/* harmony export */ });\n// local storage for question titles\r\nclass LHLocalStorage{\r\n  partitionBaseName = 'lh-storage'; // base name used for partition\r\n  storage = window.localStorage;\r\n  partitions; // chrome's localstorage can hold at most 2KB per key:value pair\r\n  partitionMaxSize = 1900; // holds at max 2KB (1.9KB to be safe) per key:value pair\r\n\r\n  constructor(){\r\n    var p = 0\r\n    // check how many partitons of lh-storage exists\r\n    while(this.storage.getItem(`${this.partitionBaseName}-${p}`) != null){\r\n      p ++;\r\n    }\r\n    this.partitions = p // we have p partitions of 2KB, starting from \"lh-storage-0\"\r\n    console.log(`current partitions: ${this.partitions}`)\r\n  }\r\n  \r\n  // private method (shouldn't be used outside this scope)\r\n  // Method returns question data from local storage partition if partition exists.\r\n  getPartitionData = (partitionName) => {\r\n    const questionData = this.storage.getItem(partitionName)\r\n    if(questionData == null){\r\n      // partition does not exists (should never be the case)\r\n      console.log(`partition ${partitionName} does not exist!`)\r\n      return null;\r\n    }\r\n    return questionData\r\n  }\r\n\r\n  // private method (shouldn't be used outside this scope)\r\n  // Method returns size of partition data (in bytes)\r\n  // should only be called if partition is present\r\n  getPartitionSize = (partitionName) => unescape(\r\n    encodeURIComponent(this.getPartitionData(partitionName))\r\n  ).length;\r\n\r\n  \r\n  // private method (shouldn't be used outside this scope)\r\n  // Method returns first available partition name. If all partitions are full, creates new one\r\n  firstAvailablePartition = (payload) => {\r\n    var p = 0;\r\n    const payloadSize = unescape(encodeURIComponent(payload)).length // size of data we want to put into partition\r\n    while(p < this.partitions){\r\n      // check to see if partition isn't too big to include the new data with itself\r\n      const questionData = this.getPartitionData(`${this.partitionBaseName}-${p}`)\r\n      if(questionData != null && \r\n        this.getPartitionSize(`${this.partitionBaseName}-${p}`) + payloadSize <= this.partitionMaxSize\r\n      ){\r\n        return `${this.partitionBaseName}-${p}`\r\n      }\r\n      p++\r\n    }\r\n    // no partitions available - create new partition\r\n    return this.generatePartition()\r\n  }\r\n\r\n  // private method (shouldn't be used outside this scope)\r\n  // Method generates a new partition and returns the partition name (key in local storage)\r\n  generatePartition = () => {\r\n    let partitionData = '';\r\n    const newPartitionName = `${this.partitionBaseName}-${this.partitions}` \r\n    this.storage.setItem(newPartitionName, partitionData) // creates new partition\r\n    this.partitions++ // increment partitions\r\n    return newPartitionName\r\n  }\r\n\r\n\r\n  /**\r\n   * Checks to see if question title is stored in local storage and returns full title. If not present in local storage, returns null\r\n   * \r\n   * @param {string} name The name of the question as defined by LeetCode (not slug format)\r\n   * For example, for \"1. Two Sum: Easy\", name should be \"Two Sum\"\r\n   * @returns {Array[string]} The title of the problem [0] and its difficulty [1]. Eg. (\"X. Question Name\", \"Easy\")\r\n   */\r\n  getQuestionTitle(name){\r\n    // make regex query across all partitions\r\n    var p = 0;\r\n    while(p < this.partitions){\r\n      const questionData = this.getPartitionData(`${this.partitionBaseName}-${p}`)\r\n      // question data is a massive string that contains name and numbers of leetcode questions\r\n      // previously stored on the local machine. It should follow the structure '1. Two Sum: Easy; 2. ...'\r\n      if(questionData){\r\n        let match = questionData.match(\r\n          new RegExp(`(\\\\d+[.]\\\\s${name}):\\\\s(Easy|Medium|Hard)`, \"i\")\r\n        ) // find match\r\n        if(match){\r\n          return match.slice(1) // eg. returns ('1. Two Sum', 'Easy')\r\n        }\r\n      }\r\n      p++\r\n    }\r\n    // question not present in any partitions\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Adds the full question title into localstorage in the first available partition\r\n   * \r\n   * @param {string} title The title (with number) of the question as defined by LeetCode (not slug format)\r\n   * For example, for Two Sum, the title should be \"1. Two Sum: Easy\"\r\n   * @returns {int} Status of upload. 0 means all went well. 1 means something went wrong. 2 means title\r\n   *  already exists in local storage\r\n   */\r\n  setQuestionTitle(title){\r\n    if(!title.match(\r\n      new RegExp(`(\\\\d+[.]\\\\s(.*)):\\\\s(Easy|Medium|Hard)`, \"i\")\r\n    )){\r\n      console.error(`Title ${title} does not match the pattern /(\\\\d+[.]\\\\(.*)):\\\\s(Easy|Medium|Hard)/i`)\r\n      return 1;\r\n    }\r\n\r\n    // check if it isn't already in local storage\r\n    let splitTitle = title.split(/\\d+[.][\\s]?(.*):\\s(Easy|Medium|Hard)/)\r\n    const questionName = splitTitle[1]\r\n    if(this.getQuestionTitle(questionName)){\r\n      console.log(`Question ${title} has already been cached.`)\r\n      return 2;\r\n    }\r\n    \r\n    // find earliest available partition\r\n    const payload = `${title}; `\r\n    let currPartition = this.firstAvailablePartition(payload)\r\n\r\n    // add payload to partition\r\n    try{\r\n      let modifiedPartitionData = this.storage.getItem(currPartition) + payload\r\n      this.storage.setItem(currPartition, modifiedPartitionData);\r\n      console.log(`successfuly saved title: ${title}`)\r\n      return 0\r\n    }\r\n    catch(err){\r\n      if (err.name === 'QuotaExceededError') {\r\n        // partition is full (theoretially should never happen as new partition is made)\r\n        console.error('\"FIRST AVAILABLE PARTITION\" IS FULL')\r\n      }\r\n      else{\r\n        throw err; // could be something else\r\n      }\r\n      return 1;\r\n    }\r\n  }\r\n}\n\n//# sourceURL=webpack://LeetHub/./src/leetcode/LHLocalStorage.js?");

/***/ }),

/***/ "./src/leetcode/leetcode.js":
/*!**********************************!*\
  !*** ./src/leetcode/leetcode.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _LHLocalStorage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LHLocalStorage */ \"./src/leetcode/LHLocalStorage.js\");\n\r\nconsole.log(\"using bundled file\")\r\n\r\n/* Enum for languages supported by LeetCode. */\r\nconst languages = {\r\n  Python: '.py',\r\n  Python3: '.py',\r\n  'C++': '.cpp',\r\n  C: '.c',\r\n  Java: '.java',\r\n  'C#': '.cs',\r\n  JavaScript: '.js',\r\n  Javascript: '.js',\r\n  Ruby: '.rb',\r\n  Swift: '.swift',\r\n  Go: '.go',\r\n  Kotlin: '.kt',\r\n  Scala: '.scala',\r\n  Rust: '.rs',\r\n  PHP: '.php',\r\n  TypeScript: '.ts',\r\n  MySQL: '.sql',\r\n  'MS SQL Server': '.sql',\r\n  Oracle: '.sql',\r\n};\r\n\r\n/* Commit messages */\r\nconst readmeMsg = 'Create README - LeetHub';\r\nconst discussionMsg = 'Prepend discussion post - LeetHub';\r\nconst createNotesMsg = 'Attach NOTES - LeetHub';\r\n\r\n// cache the base URL html file used for parsing question details with the new LeetCode UI\r\nlet newPageHTML = '';\r\n\r\n// problem types\r\nconst NORMAL_PROBLEM = 0;\r\nconst EXPLORE_SECTION_PROBLEM = 1;\r\n\r\n/* Difficulty of most recenty submitted question */\r\nlet difficulty = '';\r\n\r\n/* state of upload for progress */\r\nlet uploadState = { uploading: false };\r\nlet uploaded = false;\r\n\r\n// leecode quesiton title cache (LHLocalStorage)\r\n// only initialised when either question title is detected or needed.\r\nlet LHStorage = null;\r\nlet titleCached = false;\r\n\r\n// generate HTML file for parsing question details with the new LeetCode UI\r\nasync function generateBasePage(questionUrl){\r\n  // get base URL of leetcode problem\r\n  if (questionUrl.includes('/submissions/')) {\r\n    questionUrl = questionUrl.replace(/\\/submissions\\/.*/, '/description/')\r\n  }\r\n  /* \r\n    Many of the question details such as question title and difficulty is found in the\r\n    HTML file at the question base URL, under a script with the id \"__NEXT_DATA__\"\r\n    we can either query the entire html text which includes the script details or make\r\n    a DOM object, select the script, and query from that text.\r\n  */\r\n  // make a http request to the base URL to get html file\r\n  let basePage = await fetch(questionUrl, {method: \"GET\"})\r\n  let questionData = await basePage.text()\r\n\r\n  let script = questionData.match(/<script id=\"__NEXT_DATA__\".*>.*<\\/script>/)\r\n  \r\n  return script ? script[0] : null;\r\n}\r\n\r\n/* Get file extension for submission */\r\nfunction findLanguage() {\r\n  var tag = [\r\n    ...document.getElementsByClassName(\r\n      'ant-select-selection-selected-value',\r\n    ),\r\n    ...document.getElementsByClassName('Select-value-label'),\r\n  ];\r\n  if (tag && tag.length > 0) {\r\n    for (let i = 0; i < tag.length; i += 1) {\r\n      const elem = tag[i].textContent;\r\n      if (elem !== undefined && languages[elem] !== undefined) {\r\n        return languages[elem]; // should generate respective file extension\r\n      }\r\n    }\r\n  }\r\n  else{\r\n    // user may be using new version of LeetCode\r\n    // returns an array of language tags submitted. first and last instance is the most recent submission\r\n    tag = Array.from(document.querySelectorAll('span[class*=\"leading-\"]')).filter(elem => elem.textContent in languages)\r\n    if(!checkElem(tag)){ // something went wrong\r\n      return null\r\n    }\r\n    return languages[tag[0].textContent] // should generate respective file extension\r\n  }\r\n  return null;\r\n}\r\n\r\n/* Main function for uploading code to GitHub repo, and callback cb is called if success */\r\nconst upload = (\r\n  token,\r\n  hook,\r\n  code,\r\n  directory,\r\n  filename,\r\n  sha,\r\n  msg,\r\n  cb = undefined,\r\n) => {\r\n  // To validate user, load user object from GitHub.\r\n  const URL = `https://api.github.com/repos/${hook}/contents/${directory}/${filename}`;\r\n\r\n  /* Define Payload */\r\n  let data = {\r\n    message: msg,\r\n    content: code,\r\n    sha,\r\n  };\r\n\r\n  data = JSON.stringify(data);\r\n\r\n  const xhr = new XMLHttpRequest();\r\n  xhr.addEventListener('readystatechange', function () {\r\n    if (xhr.readyState === 4) {\r\n      if (xhr.status === 200 || xhr.status === 201) {\r\n        const updatedSha = JSON.parse(xhr.responseText).content.sha; // get updated SHA.\r\n\r\n        chrome.storage.local.get('stats', (data2) => {\r\n          let { stats } = data2;\r\n          if (stats === null || stats === {} || stats === undefined) {\r\n            // create stats object\r\n            stats = {};\r\n            stats.solved = 0;\r\n            stats.easy = 0;\r\n            stats.medium = 0;\r\n            stats.hard = 0;\r\n            stats.sha = {};\r\n          }\r\n          const filePath = directory + filename;\r\n          // Only increment solved problems statistics once\r\n          // New submission commits twice (README and problem)\r\n          if (filename === 'README.md' && sha === null) {\r\n            stats.solved += 1;\r\n            stats.easy += difficulty === 'Easy' ? 1 : 0;\r\n            stats.medium += difficulty === 'Medium' ? 1 : 0;\r\n            stats.hard += difficulty === 'Hard' ? 1 : 0;\r\n          }\r\n          stats.sha[filePath] = updatedSha; // update sha key.\r\n          chrome.storage.local.set({ stats }, () => {\r\n            console.log(\r\n              `Successfully committed ${filename} to github`,\r\n            );\r\n\r\n            // if callback is defined, call it\r\n            if (cb !== undefined) {\r\n              cb();\r\n            }\r\n          });\r\n        });\r\n      }\r\n    }\r\n  });\r\n  xhr.open('PUT', URL, true);\r\n  xhr.setRequestHeader('Authorization', `token ${token}`);\r\n  xhr.setRequestHeader('Accept', 'application/vnd.github.v3+json');\r\n  xhr.send(data);\r\n};\r\n\r\n/* Main function for updating code on GitHub Repo */\r\n/* Currently only used for prepending discussion posts to README */\r\n/* callback cb is called on success if it is defined */\r\nconst update = (\r\n  token,\r\n  hook,\r\n  addition,\r\n  directory,\r\n  msg,\r\n  prepend,\r\n  cb = undefined,\r\n) => {\r\n  const URL = `https://api.github.com/repos/${hook}/contents/${directory}/README.md`;\r\n\r\n  /* Read from existing file on GitHub */\r\n  const xhr = new XMLHttpRequest();\r\n  xhr.addEventListener('readystatechange', function () {\r\n    if (xhr.readyState === 4) {\r\n      if (xhr.status === 200 || xhr.status === 201) {\r\n        const response = JSON.parse(xhr.responseText);\r\n        const existingContent = decodeURIComponent(\r\n          escape(atob(response.content)),\r\n        );\r\n        let newContent = '';\r\n\r\n        /* Discussion posts prepended at top of README */\r\n        /* Future implementations may require appending to bottom of file */\r\n        if (prepend) {\r\n          newContent = btoa(\r\n            unescape(encodeURIComponent(addition + existingContent)),\r\n          );\r\n        }\r\n\r\n        /* Write file with new content to GitHub */\r\n        upload(\r\n          token,\r\n          hook,\r\n          newContent,\r\n          directory,\r\n          'README.md',\r\n          response.sha,\r\n          msg,\r\n          cb,\r\n        );\r\n      }\r\n    }\r\n  });\r\n  xhr.open('GET', URL, true);\r\n  xhr.setRequestHeader('Authorization', `token ${token}`);\r\n  xhr.setRequestHeader('Accept', 'application/vnd.github.v3+json');\r\n  xhr.send();\r\n};\r\n\r\nfunction uploadGit(\r\n  code,\r\n  problemName,\r\n  fileName,\r\n  msg,\r\n  action,\r\n  prepend = true,\r\n  cb = undefined,\r\n  _diff = undefined,\r\n) {\r\n  // Assign difficulty\r\n  if (_diff && _diff !== undefined) {\r\n    difficulty = _diff.trim();\r\n  }\r\n\r\n  /* Get necessary payload data */\r\n  chrome.storage.local.get('leethub_token', (t) => {\r\n    const token = t.leethub_token;\r\n    if (token) {\r\n      chrome.storage.local.get('mode_type', (m) => {\r\n        const mode = m.mode_type;\r\n        if (mode === 'commit') {\r\n          /* Get hook */\r\n          chrome.storage.local.get('leethub_hook', (h) => {\r\n            const hook = h.leethub_hook;\r\n            if (hook) {\r\n              /* Get SHA, if it exists */\r\n\r\n              /* to get unique key */\r\n              const filePath = problemName + fileName;\r\n              chrome.storage.local.get('stats', (s) => {\r\n                const { stats } = s;\r\n                let sha = null;\r\n\r\n                if (\r\n                  stats !== undefined &&\r\n                  stats.sha !== undefined &&\r\n                  stats.sha[filePath] !== undefined\r\n                ) {\r\n                  sha = stats.sha[filePath];\r\n                }\r\n\r\n                if (action === 'upload') {\r\n                  /* Upload to git. */\r\n                  upload(\r\n                    token,\r\n                    hook,\r\n                    code,\r\n                    problemName,\r\n                    fileName,\r\n                    sha,\r\n                    msg,\r\n                    cb,\r\n                  );\r\n                } else if (action === 'update') {\r\n                  /* Update on git */\r\n                  update(\r\n                    token,\r\n                    hook,\r\n                    code,\r\n                    problemName,\r\n                    msg,\r\n                    prepend,\r\n                    cb,\r\n                  );\r\n                }\r\n              });\r\n            }\r\n          });\r\n        }\r\n      });\r\n    }\r\n  });\r\n}\r\n\r\n/* Function for finding and parsing the full code. */\r\n/* - At first find the submission details url. */\r\n/* - Then send a request for the details page. */\r\n/* - Finally, parse the code from the html reponse. */\r\n/* - Also call the callback if available when upload is success */\r\nfunction findCode(\r\n  uploadGit,\r\n  problemName,\r\n  fileName,\r\n  msg,\r\n  action,\r\n  cb = undefined,\r\n) {\r\n  /* Get the submission details url from the submission page. */\r\n  var submissionURL;\r\n  const e = document.getElementsByClassName('status-column__3SUg');\r\n  if (checkElem(e)) {\r\n    // for normal problem submisson\r\n    const submissionRef = e[1].innerHTML.split(' ')[1];\r\n    submissionURL =\r\n      'https://leetcode.com' +\r\n      submissionRef.split('=')[1].slice(1, -1);\r\n  } else {\r\n    // for a submission in explore section\r\n    const submissionRef = document.getElementById('result-state');\r\n    submissionURL = submissionRef?.href;\r\n  }\r\n\r\n  console.log(`submission URL: ${submissionURL}`)\r\n\r\n  if (submissionURL != undefined) {\r\n    /* Request for the submission details page */\r\n    const xhttp = new XMLHttpRequest();\r\n    xhttp.onreadystatechange = function () {\r\n      if (this.readyState == 4 && this.status == 200) {\r\n        /* received submission details as html reponse. */\r\n        var doc = new DOMParser().parseFromString(\r\n          this.responseText,\r\n          'text/html',\r\n        );\r\n        /* the response has a js object called pageData. */\r\n        /* Pagedata has the details data with code about that submission */\r\n        var scripts = doc.getElementsByTagName('script');\r\n        for (var i = 0; i < scripts.length; i++) {\r\n          var text = scripts[i].innerText;\r\n          if (text.includes('pageData')) {\r\n            /* Considering the pageData as text and extract the substring\r\n            which has the full code */\r\n            var firstIndex = text.indexOf('submissionCode');\r\n            var lastIndex = text.indexOf('editCodeUrl');\r\n            var slicedText = text.slice(firstIndex, lastIndex);\r\n            /* slicedText has code as like as. (submissionCode: 'Details code'). */\r\n            /* So finding the index of first and last single inverted coma. */\r\n            var firstInverted = slicedText.indexOf(\"'\");\r\n            var lastInverted = slicedText.lastIndexOf(\"'\");\r\n            /* Extract only the code */\r\n            var codeUnicoded = slicedText.slice(\r\n              firstInverted + 1,\r\n              lastInverted,\r\n            );\r\n            /* The code has some unicode. Replacing all unicode with actual characters */\r\n            var code = codeUnicoded.replace(\r\n              /\\\\u[\\dA-F]{4}/gi,\r\n              function (match) {\r\n                return String.fromCharCode(\r\n                  parseInt(match.replace(/\\\\u/g, ''), 16),\r\n                );\r\n              },\r\n            );\r\n\r\n            /*\r\n            for a submisssion in explore section we do not get probStat beforehand\r\n            so, parse statistics from submisson page\r\n            */\r\n            if (!msg) {\r\n              slicedText = text.slice(\r\n                text.indexOf('runtime'),\r\n                text.indexOf('memory'),\r\n              );\r\n              const resultRuntime = slicedText.slice(\r\n                slicedText.indexOf(\"'\") + 1,\r\n                slicedText.lastIndexOf(\"'\"),\r\n              );\r\n              slicedText = text.slice(\r\n                text.indexOf('memory'),\r\n                text.indexOf('total_correct'),\r\n              );\r\n              const resultMemory = slicedText.slice(\r\n                slicedText.indexOf(\"'\") + 1,\r\n                slicedText.lastIndexOf(\"'\"),\r\n              );\r\n              msg = `Time: ${resultRuntime}, Memory: ${resultMemory} - LeetHub`;\r\n            }\r\n\r\n            if (code != null) {\r\n              setTimeout(function () {\r\n                uploadGit(\r\n                  btoa(unescape(encodeURIComponent(code))),\r\n                  problemName,\r\n                  fileName,\r\n                  msg,\r\n                  action,\r\n                  true,\r\n                  cb,\r\n                );\r\n              }, 2000);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    xhttp.open('GET', submissionURL, true);\r\n    xhttp.send();\r\n  }\r\n  else{\r\n    // user may be using newer version of Leetcode.\r\n    // when submitted, user is directed to submission page with the code already present\r\n    // therefore we don't need to make a http request.\r\n\r\n    // code can be found from the <code> tag\r\n    let code = \"\"\r\n    Array.from(document.querySelectorAll(\"code\")[0]?.children).forEach((line) => {code += `${line.textContent}`})\r\n    \r\n    if(!msg){\r\n      // TODO: get statistics from submission page for new explore section??\r\n      return null;\r\n    }\r\n\r\n    if (code != null) {\r\n      setTimeout(function () {\r\n        uploadGit(\r\n          btoa(unescape(encodeURIComponent(code))),\r\n          problemName,\r\n          fileName,\r\n          msg,\r\n          action,\r\n          true,\r\n          cb,\r\n        );\r\n      }, 2000);\r\n    }\r\n  }\r\n}\r\n\r\n/* Main parser function for the code */\r\nfunction parseCode() {\r\n  const e = document.getElementsByClassName('CodeMirror-code');\r\n  if (e !== undefined && e.length > 0) {\r\n    const elem = e[0];\r\n    let parsedCode = '';\r\n    const textArr = elem.innerText.split('\\n');\r\n    for (let i = 1; i < textArr.length; i += 2) {\r\n      parsedCode += `${textArr[i]}\\n`;\r\n    }\r\n    return parsedCode;\r\n  }\r\n  return null;\r\n}\r\n\r\n/* Util function to check if an element exists */\r\nfunction checkElem(elem) {\r\n  return elem && elem.length > 0;\r\n}\r\nfunction convertToSlug(string) {\r\n  const a =\r\n    'àáâäæãåāăąçćčđďèéêëēėęěğǵḧîïíīįìłḿñńǹňôöòóœøōõőṕŕřßśšşșťțûüùúūǘůűųẃẍÿýžźż·/_,:;';\r\n  const b =\r\n    'aaaaaaaaaacccddeeeeeeeegghiiiiiilmnnnnoooooooooprrsssssttuuuuuuuuuwxyyzzz------';\r\n  const p = new RegExp(a.split('').join('|'), 'g');\r\n\r\n  return string\r\n    .toString()\r\n    .toLowerCase()\r\n    .replace(/\\s+/g, '-') // Replace spaces with -\r\n    .replace(p, (c) => b.charAt(a.indexOf(c))) // Replace special characters\r\n    .replace(/&/g, '-and-') // Replace & with 'and'\r\n    .replace(/[^\\w\\-]+/g, '') // Remove all non-word characters\r\n    .replace(/\\-\\-+/g, '-') // Replace multiple - with single -\r\n    .replace(/^-+/, '') // Trim - from start of text\r\n    .replace(/-+$/, ''); // Trim - from end of text\r\n}\r\nasync function getProblemNameSlug() {\r\n  const questionElem = document.getElementsByClassName(\r\n    'content__u3I1 question-content__JfgR',\r\n  );\r\n  const questionDescriptionElem = document.getElementsByClassName(\r\n    'question-description__3U1T',\r\n  );\r\n  let questionTitle = 'unknown-problem';\r\n  if (checkElem(questionElem)) {\r\n    let qtitle = document.getElementsByClassName('css-v3d350');\r\n    if (checkElem(qtitle)) {\r\n      questionTitle = qtitle[0].innerHTML;\r\n    }\r\n  } else if (checkElem(questionDescriptionElem)) {\r\n    let qtitle = document.getElementsByClassName('question-title');\r\n    if (checkElem(qtitle)) {\r\n      questionTitle = qtitle[0].innerText;\r\n    }\r\n  }\r\n  else{\r\n    // user may be using newer version of LeetCode\r\n    // check if problem title is stored in local storage\r\n    const questionName = document.title.split(/(.*) - LeetCode/i)[1]\r\n    LHStorage = LHStorage ? LHStorage : new _LHLocalStorage__WEBPACK_IMPORTED_MODULE_0__[\"default\"]()// initialise if not already initialised\r\n    let qtitle = LHStorage.getQuestionTitle(questionName)\r\n    if(qtitle){\r\n      questionTitle = qtitle[0]\r\n      console.log(\"got question title from cache!\")\r\n    }\r\n    else{ \r\n      // FALLBACK IF NOT CACHED, make HTTP request to attempt. \r\n      // This method only works ~40% of the time (for some reason)\r\n      \r\n      // get the script from the html file at the base URL\r\n      if(!newPageHTML){\r\n        newPageHTML = await generateBasePage(window.location.href);\r\n      }\r\n      // if newPageHTML returns null, return an error.\r\n      if(!newPageHTML){\r\n        console.error(\"Cannot find title of leetcode problem.\")\r\n        return;\r\n      }\r\n  \r\n      // from the html text, get title and difficulty of question\r\n      let questionNo = RegExKeyMatch(\"questionFrontendId\", newPageHTML)\r\n      if(!questionNo){ // user may be using explore section or something went wrong\r\n        // TODO: generate question title from \r\n        return null;\r\n      }\r\n      \r\n      questionTitle = `${questionNo}. ${questionName}`\r\n    }\r\n  }\r\n  return addLeadingZeros(convertToSlug(questionTitle));\r\n}\r\n\r\nfunction addLeadingZeros(title) {\r\n  const maxTitlePrefixLength = 4;\r\n  var len = title.split('-')[0].length;\r\n  if (len < maxTitlePrefixLength) {\r\n    return '0'.repeat(4 - len) + title;\r\n  }\r\n  return title;\r\n}\r\n\r\n// returns value from a \"key\":\"value\" pair in a given string. if key is not present, returns null\r\nfunction RegExKeyMatch(key, str){\r\n  const match = str.match(new RegExp(`\"${key}\":\"([^\"]+)\"`))\r\n  return match ? match[1] : null\r\n}\r\n\r\n/* Parser function for the question and tags */\r\nasync function parseQuestion() {\r\n  var qtitle;\r\n  var qbody;\r\n  \r\n  // get base URL of leetcode problem\r\n  var questionUrl = window.location.href;\r\n  if (questionUrl.includes('/submissions/')) {\r\n    questionUrl = questionUrl.substring(\r\n      0,\r\n      questionUrl.lastIndexOf('/submissions/') + 1,\r\n    );\r\n  }\r\n  \r\n  var questionElem = document.getElementsByClassName(\r\n    'content__u3I1 question-content__JfgR',\r\n  );\r\n\r\n  var questionDescriptionElem = document.getElementsByClassName(\r\n    'question-description__3U1T',\r\n  );\r\n\r\n  if (checkElem(questionElem)) {\r\n    qbody = questionElem[0].innerHTML;\r\n\r\n    // Problem title.\r\n    qtitle = document.getElementsByClassName('css-v3d350');\r\n    if (checkElem(qtitle)) {\r\n      qtitle = qtitle[0].innerHTML;\r\n    } else {\r\n      qtitle = 'unknown-problem';\r\n    }\r\n\r\n    // Problem difficulty, each problem difficulty has its own class.\r\n    const isHard = document.getElementsByClassName('css-t42afm');\r\n    const isMedium = document.getElementsByClassName('css-dcmtd5');\r\n    const isEasy = document.getElementsByClassName('css-14oi08n');\r\n\r\n    if (checkElem(isEasy)) {\r\n      difficulty = 'Easy';\r\n    } else if (checkElem(isMedium)) {\r\n      difficulty = 'Medium';\r\n    } else if (checkElem(isHard)) {\r\n      difficulty = 'Hard';\r\n    }\r\n    // Final formatting of the contents of the README for each problem\r\n    const markdown = `<h2><a href=\"${questionUrl}\">${qtitle}</a></h2><h3>${difficulty}</h3><hr>${qbody}`;\r\n    return markdown;\r\n  } \r\n  else if (checkElem(questionDescriptionElem)) {\r\n    let questionTitle = document.getElementsByClassName(\r\n      'question-title',\r\n    );\r\n    if (checkElem(questionTitle)) {\r\n      questionTitle = questionTitle[0].innerText;\r\n    } else {\r\n      questionTitle = 'unknown-problem';\r\n    }\r\n\r\n    const questionBody = questionDescriptionElem[0].innerHTML;\r\n    const markdown = `<h2>${questionTitle}</h2><hr>${questionBody}`;\r\n\r\n    return markdown;\r\n  }\r\n  else{\r\n    // user is using new version of LeetCode\r\n    const questionName = document.title.split(/(.*) - LeetCode/i)[1]\r\n    LHStorage = LHStorage ? LHStorage : new _LHLocalStorage__WEBPACK_IMPORTED_MODULE_0__[\"default\"]()// initialise if not already initialised\r\n    let questionTitle = LHStorage.getQuestionTitle(questionName)\r\n    if(questionTitle){\r\n      [qtitle, difficulty] = questionTitle\r\n      console.log(\"got question title and difficulty from cache!\")\r\n    }\r\n    else{\r\n      // FALLBACK IF NOT CACHED, make HTTP request to attempt. \r\n      // This method only works ~40% of the time (for some reason)\r\n      // get the html text from the base URL\r\n      if(!newPageHTML){\r\n        newPageHTML = await generateBasePage(window.location.href);\r\n      }\r\n      // if newPageHTML returns null, return an error.\r\n      if(!newPageHTML){\r\n        console.error(\"Cannot find description of leetcode problem.\")\r\n        return;\r\n      }\r\n      // from the html text, get title and difficulty of question\r\n      let questionNo = RegExKeyMatch(\"questionFrontendId\", newPageHTML)\r\n      difficulty = RegExKeyMatch(\"difficulty\", newPageHTML)\r\n  \r\n      if(!(questionNo || questionName)){ // either using explore section or something went wrong\r\n        // TODO: look for the explore question data \r\n        return null;\r\n      }\r\n      \r\n      // form title and get question description\r\n      qtitle = `${questionNo}. ${questionName}`\r\n    }\r\n    \r\n    qbody = document.head.querySelector('meta[name=\"description\"]').content\r\n    \r\n    // Final formatting of the contents of the README for each problem\r\n    const markdown = `<h2><a href=\"${questionUrl}\">${qtitle}</a></h2><h3>${difficulty}</h3><hr>${qbody}`;\r\n    return markdown;\r\n  }\r\n}\r\n\r\n/* For LeetCode's new UI, percentage int and decimal are seperated, but contained in a single div.\r\nThe function brings them together to a single string */\r\nfunction parsePercentileNew(elem){\r\n  let spans = Array.from(elem.querySelectorAll(\"span\"))\r\n  let percentage = \"\"\r\n  spans.forEach(elem => {\r\n    percentage += elem.textContent\r\n  })\r\n\r\n  return percentage\r\n}\r\n\r\n/* Parser function for time/space stats */\r\nfunction parseStats() {\r\n  let time, timePercentile, space, spacePercentile;\r\n  const probStats = document.getElementsByClassName('data__HC-i');\r\n  \r\n  if (checkElem(probStats)) {\r\n    time = probStats[0].textContent;\r\n    timePercentile = probStats[1].textContent;\r\n    space = probStats[2].textContent;\r\n    spacePercentile = probStats[3].textContent;\r\n  }\r\n  else{\r\n    // user may be using a newer version of LeetCode\r\n    let newProbStats = document.getElementsByClassName(\"gap-y-2\");\r\n    if(!checkElem(newProbStats)){\r\n      return null;\r\n    }\r\n\r\n    //for each stat (time, mem), get their values and percentiles\r\n    let stats = []\r\n    Array.from(newProbStats).forEach(stat => {\r\n      let [val, per] = stat.querySelectorAll(\"div\")\r\n    \r\n      stats.push(val.querySelectorAll(\"*\")[1].textContent)\r\n      stats.push(parsePercentileNew(per.querySelectorAll(\"*\")[1]))\r\n    });\r\n\r\n    [time, timePercentile, space, spacePercentile] = stats\r\n  }\r\n\r\n  // Format commit message\r\n  return `Time: ${time} (${timePercentile}), Space: ${space} (${spacePercentile}) - LeetHub`;\r\n}\r\n\r\ndocument.addEventListener('click', (event) => {\r\n  const element = event.target;\r\n  const oldPath = window.location.pathname;\r\n\r\n  /* Act on Post button click */\r\n  /* Complex since \"New\" button shares many of the same properties as \"Post button */\r\n  if (\r\n    element.classList.contains('icon__3Su4') ||\r\n    element.parentElement.classList.contains('icon__3Su4') ||\r\n    element.parentElement.classList.contains(\r\n      'btn-content-container__214G',\r\n    ) ||\r\n    element.parentElement.classList.contains('header-right__2UzF')\r\n  ) {\r\n    setTimeout(function () {\r\n      /* Only post if post button was clicked and url changed */\r\n      if (\r\n        oldPath !== window.location.pathname &&\r\n        oldPath ===\r\n          window.location.pathname.substring(0, oldPath.length) &&\r\n        !Number.isNaN(window.location.pathname.charAt(oldPath.length))\r\n      ) {\r\n        const date = new Date();\r\n        const currentDate = `${date.getDate()}/${date.getMonth()}/${date.getFullYear()} at ${date.getHours()}:${date.getMinutes()}`;\r\n        const addition = `[Discussion Post (created on ${currentDate})](${window.location})  \\n`;\r\n        const problemName = window.location.pathname.split('/')[2]; // must be true.\r\n\r\n        uploadGit(\r\n          addition,\r\n          problemName,\r\n          'README.md',\r\n          discussionMsg,\r\n          'update',\r\n        );\r\n      }\r\n    }, 1000);\r\n  }\r\n});\r\n\r\n// Leetcode's new UI means that we cannot obtain notes on description page when on submission page\r\n// This generates a submission button to allow users to manually submit notes on the submission page.\r\nfunction generateNoteSubmissionButton(){\r\n  // find anchor for note submission\r\n  const noteSection = Array.from(document.querySelectorAll(\"textarea\")).filter(\r\n    elem => elem.getAttribute(\"name\") == \"notes\"\r\n  );\r\n  if(checkElem(noteSection)){\r\n    // get style from submit button\r\n    const style = Array.from(document.getElementsByTagName(\"button\")).filter(\r\n      elem => elem.classList.contains(\"bg-green-s\")\r\n    )[0]?.className;\r\n    // place new button with this style under the note section\r\n    const submitNotesButton = document.createElement(\"button\");\r\n    submitNotesButton.appendChild(document.createTextNode(\"Submit Notes - LeetHub\")); // adds text to button\r\n    submitNotesButton.className = `${style} leethub-notes-submission`; // add submit button's style as well as an indicator class\r\n    submitNotesButton.style.cssText += \"margin: 1em 0;\";// add some margin for space\r\n    submitNotesButton.addEventListener(\"click\", onNoteSubmission); // add event listener\r\n\r\n    noteSection[0].after(submitNotesButton); // insert button\r\n  }\r\n}\r\n\r\n// Leetcode's new UI means that we cannot obtain notes on description page when on submission page\r\n// This runs once the note submission button is clicked.\r\nasync function onNoteSubmission(e){\r\n  const button = e.target;\r\n  if(button.classList.contains(\"cursor-not-allowed\")){\r\n    // button disabled (maybe user already uploaded to GitHub)\r\n    console.log(\"button is disabled\");\r\n    return;\r\n  }\r\n  button.className += ' cursor-not-allowed opacity-50'; // leetcode's classes for disabled buttons\r\n  // get notes from textarea before the button\r\n  const notes = button.previousSibling?.textContent;\r\n  if(!notes){\r\n    console.error(\"cannot find notes section\");\r\n    return;\r\n  }\r\n  // If there's any notes, upload it to git\r\n  if (notes.length > 0) {\r\n    let problemName = await getProblemNameSlug();\r\n    setTimeout(function () {\r\n      if (notes != undefined && notes.length != 0) {\r\n        console.log('Create Notes');\r\n        // means we can upload the notes too\r\n        uploadGit(\r\n          btoa(unescape(encodeURIComponent(notes))),\r\n          problemName,\r\n          'NOTES.md',\r\n          createNotesMsg,\r\n          'upload',\r\n        );\r\n      }\r\n    }, 500);\r\n  }\r\n  else{\r\n    console.log(\"no notes added\")\r\n    button.className = button.className.remove(/ cursor-not-allowed opacity-50/)\r\n  }\r\n}\r\n\r\n/* function to get the notes if there is any\r\n the note should be opened atleast once for this to work\r\n this is because the dom is populated after data is fetched by opening the note */\r\n// TODO: update function to support both old and new LeetCode UI\r\nfunction getNotesIfAny() {\r\n  // there are no notes on expore\r\n  if (document.URL.startsWith('https://leetcode.com/explore/'))\r\n    return '';\r\n\r\n  let notes = '';\r\n  if (\r\n    checkElem(document.getElementsByClassName('notewrap__eHkN')) &&\r\n    checkElem(\r\n      document\r\n        .getElementsByClassName('notewrap__eHkN')[0]\r\n        .getElementsByClassName('CodeMirror-code'),\r\n    )\r\n  ) {\r\n    notesdiv = document\r\n      .getElementsByClassName('notewrap__eHkN')[0]\r\n      .getElementsByClassName('CodeMirror-code')[0];\r\n    if (notesdiv) {\r\n      for (i = 0; i < notesdiv.childNodes.length; i++) {\r\n        if (notesdiv.childNodes[i].childNodes.length == 0) continue;\r\n        text = notesdiv.childNodes[i].childNodes[0].innerText;\r\n        if (text) {\r\n          notes = `${notes}\\n${text.trim()}`.trim();\r\n        }\r\n      }\r\n    }\r\n  }\r\n  else{\r\n    // user may be using new version of LeetCode\r\n    if(!checkElem(\r\n      document.getElementsByClassName(\"leethub-notes-submission\")\r\n    )){\r\n      // generate a button for submitting notes\r\n      setTimeout(generateNoteSubmissionButton(), 500)\r\n    }\r\n  }\r\n  return notes.trim();\r\n}\r\n\r\n// listens for an indicator that we are on the description page of a problem. If so, \r\n// initialises the LeetHub LocalStorage class to cache the question title and difficulty\r\nfunction checkForTitle(){\r\n  // check to see if problem title is visible (eg. if user on description page)\r\n  const qNameOld = document.getElementsByClassName('css-v3d350');\r\n  const qNameNew = Array.from(document.querySelectorAll(\"span.mr-2\")).filter(\r\n    elem => elem.textContent.match(/\\d+[.][\\s]?.*/)\r\n  )\r\n  let qName = (\r\n    checkElem(qNameOld) ? qNameOld :  false || \r\n    checkElem(qNameNew) ? qNameNew :  false || \r\n    []\r\n  )\r\n  if(checkElem(qName)){\r\n    // check question difficulty\r\n    const isHard = (\r\n      checkElem(document.getElementsByClassName('css-t42afm')) ||\r\n      checkElem(document.querySelectorAll('div.bg-pink.capitalize'))\r\n    );\r\n    const isMedium = (\r\n      checkElem(document.getElementsByClassName('css-dcmtd5')) ||\r\n      checkElem(document.querySelectorAll('div.bg-yellow.capitalize'))\r\n    )\r\n    const isEasy = (\r\n      checkElem(document.getElementsByClassName('css-14oi08n')) ||\r\n      checkElem(document.querySelectorAll('div.bg-olive.capitalize'))\r\n    )\r\n  \r\n    difficulty = (\r\n      isEasy ? 'Easy' :  false ||\r\n      isMedium ? 'Medium':  false ||\r\n      isHard ? 'Hard' : null\r\n    )\r\n\r\n    LHStorage = new _LHLocalStorage__WEBPACK_IMPORTED_MODULE_0__[\"default\"]() // hover over object methods for descriptions\r\n    LHStorage.setQuestionTitle(`${qName[0].textContent}: ${difficulty}`) // FOLLOW 'X. Problem Name: Difficulty'\r\n    titleCached = true;\r\n  }\r\n}\r\n\r\nconst loader = setInterval(async () => {\r\n  if(!titleCached){ // check if title is visible to cache\r\n    checkForTitle()\r\n  }\r\n  if(uploaded){ // do not reupload once uploaded\r\n    return;\r\n  }\r\n\r\n  let code = null;\r\n  let probStatement = null;\r\n  let probStats = null;\r\n  let probType;\r\n\r\n  // query for old \"Success\" tag\r\n  const successfulOld = () => {\r\n    const successTag = document.getElementsByClassName('success__3Ai7')\r\n\r\n    // check if both the success tag exists, its accompanied by the \"Success\" text and it is not\r\n    // already processed\r\n    return (\r\n    checkElem(successTag) &&\r\n    successTag[0].className === 'success__3Ai7' &&\r\n    successTag[0].innerText.trim() === 'Success'\r\n    ) ?\r\n    successTag : null\r\n  }\r\n  // query for new \"Accepted\" tag\r\n  const successfulNew = () => {\r\n    const successTag = Array.from(document.getElementsByClassName(\"text-green-s\")).filter(elem => elem.querySelector(\"svg\"))\r\n\r\n    // check if both the success icon exists, its accompanied by the \"Accepted\" text and it is not\r\n    // already processed\r\n    return (\r\n      checkElem(successTag) &&\r\n      !successTag[0].classList.contains(\"marked_as_success\") &&\r\n      successTag[0].querySelector(\"span\")?.textContent == \"Accepted\"\r\n    ) ?\r\n    successTag : null\r\n  }\r\n  const successTag = successfulOld() || successfulNew() || [];\r\n\r\n  // TODO: try get result state for an explore section problem in both old and new versions\r\n  const resultState = document.getElementById('result-state');\r\n  \r\n  \r\n  var success = false;\r\n  // check success tag for a normal problem\r\n  if (\r\n    checkElem(successTag)\r\n  ) {\r\n    //console.log(successTag[0]);\r\n    success = true;\r\n    probType = NORMAL_PROBLEM;\r\n  }\r\n\r\n  // check success state for a explore section problem\r\n  else if (\r\n    resultState &&\r\n    resultState.className === 'text-success' &&\r\n    resultState.innerText === 'Accepted'\r\n  ) {\r\n    success = true;\r\n    probType = EXPLORE_SECTION_PROBLEM;\r\n  }\r\n\r\n  if (success) {\r\n    probStatement = await parseQuestion();\r\n    probStats = parseStats();\r\n  }\r\n\r\n  if (probStatement !== null) {\r\n    switch (probType) {\r\n      case NORMAL_PROBLEM:\r\n        successTag[0].classList.add('marked_as_success');\r\n        break;\r\n      case EXPLORE_SECTION_PROBLEM:\r\n        resultState.classList.add('marked_as_success');\r\n        break;\r\n      default:\r\n        console.error(`Unknown problem type ${probType}`);\r\n        return;\r\n    }\r\n\r\n    const problemName = await getProblemNameSlug();\r\n    const language = findLanguage();\r\n    if (language !== null) {\r\n      // start upload indicator here\r\n      startUpload();\r\n      chrome.storage.local.get('stats', (s) => {\r\n        const { stats } = s;\r\n        const filePath = problemName + problemName + language;\r\n        let sha = null;\r\n        if (\r\n          stats !== undefined &&\r\n          stats.sha !== undefined &&\r\n          stats.sha[filePath] !== undefined\r\n        ) {\r\n          sha = stats.sha[filePath];\r\n        }\r\n\r\n        /* Only create README if not already created */\r\n        if (sha === null) {\r\n          /* @TODO: Change this setTimeout to Promise */\r\n          uploadGit(\r\n            btoa(unescape(encodeURIComponent(probStatement))),\r\n            problemName,\r\n            'README.md',\r\n            readmeMsg,\r\n            'upload',\r\n          );\r\n        }\r\n      });\r\n\r\n      /* get the notes and upload it */\r\n      /* only upload notes if there is any */\r\n      // NOTE: getNotesIfAny currently supportes only LeetCode's old UI\r\n      const notes = getNotesIfAny();\r\n      if (notes.length > 0) {\r\n        setTimeout(function () {\r\n          if (notes != undefined && notes.length != 0) {\r\n            console.log('Create Notes');\r\n            // means we can upload the notes too\r\n            uploadGit(\r\n              btoa(unescape(encodeURIComponent(notes))),\r\n              problemName,\r\n              'NOTES.md',\r\n              createNotesMsg,\r\n              'upload',\r\n            );\r\n          }\r\n        }, 500);\r\n      }\r\n\r\n      /* Upload code to Git */\r\n      setTimeout(function () {\r\n        findCode(\r\n          uploadGit,\r\n          problemName,\r\n          problemName + language,\r\n          probStats,\r\n          'upload',\r\n          // callback is called when the code upload to git is a success\r\n          () => {\r\n            if (uploadState['countdown'])\r\n              clearTimeout(uploadState['countdown']);\r\n            delete uploadState['countdown'];\r\n            uploadState.uploading = false;\r\n            markUploaded();\r\n          },\r\n        ); // Encode `code` to base64\r\n      }, 1000);\r\n    }\r\n  }\r\n}, 1000);\r\n\r\n/* Since we dont yet have callbacks/promises that helps to find out if things went bad */\r\n/* we will start 10 seconds counter and even after that upload is not complete, then we conclude its failed */\r\nfunction startUploadCountDown() {\r\n  uploadState.uploading = true;\r\n  uploadState['countdown'] = setTimeout(() => {\r\n    if ((uploadState.uploading = true)) {\r\n      // still uploading, then it failed\r\n      uploadState.uploading = false;\r\n      markUploadFailed();\r\n    }\r\n  }, 10000);\r\n}\r\n\r\n/* we will need specific anchor element that is specific to the page you are in Eg. Explore */\r\nfunction insertToAnchorElement(elem) {\r\n  var target;\r\n  if (document.URL.startsWith('https://leetcode.com/explore/')) {\r\n    // means we are in explore page\r\n    let action = document.getElementsByClassName('action');\r\n    if (\r\n      checkElem(action) &&\r\n      checkElem(action[0].getElementsByClassName('row')) &&\r\n      checkElem(\r\n        action[0]\r\n          .getElementsByClassName('row')[0]\r\n          .getElementsByClassName('col-sm-6'),\r\n      ) &&\r\n      action[0]\r\n        .getElementsByClassName('row')[0]\r\n        .getElementsByClassName('col-sm-6').length > 1\r\n    ) {\r\n      target = action[0]\r\n        .getElementsByClassName('row')[0]\r\n        .getElementsByClassName('col-sm-6')[1];\r\n      elem.className = 'pull-left';\r\n      if (target.childNodes.length > 0)\r\n        target.childNodes[0].prepend(elem);\r\n    }\r\n  } else {\r\n    if (checkElem(document.getElementsByClassName('action__38Xc'))) {\r\n      target = document.getElementsByClassName('action__38Xc')[0];\r\n      elem.className = 'runcode-wrapper__8rXm';\r\n      if (target.childNodes.length > 0)\r\n        target.childNodes[0].prepend(elem);\r\n    }\r\n  }\r\n}\r\n\r\n/* start upload will inject a spinner on left side to the \"Run Code\" button */\r\nfunction startUpload() {\r\n  var target;\r\n  try {\r\n    let elem = document.getElementById('leethub_progress_anchor_element');\r\n    if (!elem) {\r\n      elem = document.createElement('span');\r\n      elem.id = 'leethub_progress_anchor_element';\r\n      elem.style = 'margin-right: 20px;padding-top: 2px;';\r\n    }\r\n    elem.innerHTML = `<div id=\"leethub_progress_elem\" class=\"leethub_progress\"></div>`;\r\n    target = insertToAnchorElement(elem);\r\n    // start the countdown\r\n    startUploadCountDown();\r\n  } catch (error) {\r\n    // generic exception handler for time being so that existing feature doesnt break but\r\n    // error gets logged\r\n    console.log(error);\r\n  }\r\n}\r\n\r\n/* This will create a tick mark before \"Run Code\" button signalling LeetHub has done its job */\r\nfunction markUploaded() {\r\n  uploaded = true;\r\n  const elem = document.getElementById('leethub_progress_elem');\r\n  if (elem) {\r\n    elem.className = '';\r\n    const style =\r\n      'display: inline-block;transform: rotate(45deg);height:24px;width:12px;border-bottom:7px solid #78b13f;border-right:7px solid #78b13f;';\r\n    elem.style = style;\r\n  }\r\n}\r\n\r\n/* This will create a failed tick mark before \"Run Code\" button signalling that upload failed */\r\nfunction markUploadFailed() {\r\n  const elem = document.getElementById('leethub_progress_elem');\r\n  if (elem) {\r\n    elem.className = '';\r\n    const style =\r\n      'display: inline-block;transform: rotate(45deg);height:24px;width:12px;border-bottom:7px solid red;border-right:7px solid red;';\r\n    elem.style = style;\r\n  }\r\n}\r\n\r\n/* Sync to local storage */\r\nchrome.storage.local.get('isSync', (data) => {\r\n  const keys = [\r\n    'leethub_token',\r\n    'leethub_username',\r\n    'pipe_leethub',\r\n    'stats',\r\n    'leethub_hook',\r\n    'mode_type',\r\n  ];\r\n  if (!data || !data.isSync) {\r\n    keys.forEach((key) => {\r\n      chrome.storage.sync.get(key, (data) => {\r\n        chrome.storage.local.set({ [key]: data[key] });\r\n      });\r\n    });\r\n    chrome.storage.local.set({ isSync: true }, (data) => {\r\n      console.log('LeetHub Synced to local values');\r\n    });\r\n  } else {\r\n    console.log('LeetHub Local storage already synced!');\r\n  }\r\n});\r\n\r\n// inject the style\r\ninjectStyle();\r\n\r\n/* inject css style required for the upload progress feature */\r\nfunction injectStyle() {\r\n  const style = document.createElement('style');\r\n  style.textContent =\r\n    '.leethub_progress {pointer-events: none;width: 2.0em;height: 2.0em;border: 0.4em solid transparent;border-color: #eee;border-top-color: #3E67EC;border-radius: 50%;animation: loadingspin 1s linear infinite;} @keyframes loadingspin { 100% { transform: rotate(360deg) }}';\r\n  document.head.append(style);\r\n}\r\n\n\n//# sourceURL=webpack://LeetHub/./src/leetcode/leetcode.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/leetcode/leetcode.js");
/******/ 	
/******/ })()
;